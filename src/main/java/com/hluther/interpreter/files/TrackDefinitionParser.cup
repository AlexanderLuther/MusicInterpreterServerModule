package com.hluther.interpreter.parser;

import com.hluther.interpreter.lexer.TrackLexer;
import java.util.LinkedList;
import com.hluther.entity.MError;
import java_cup.runtime.*;
import com.hluther.interpreter.ast.method.*;
import com.hluther.interpreter.ast.instruction.*;
import com.hluther.interpreter.ast.track.*;
import com.hluther.interpreter.ast.table.typeTable.SymbolType;
import com.hluther.interpreter.ast.operation.*;
import com.hluther.interpreter.ast.controlInstruction.*;


parser code {:

    private LinkedList<MError> syntacticErrors = new LinkedList();
    private Track track;
    
    public TrackParser(TrackLexer lexer) { 
        super(lexer);
    }

    public LinkedList<MError> getSyntacticErrors(){
        return syntacticErrors;
    }

    public Track getTrack(){
        return track;
    }

    private void addSyntacticError(MError error){
        syntacticErrors.add(error);
    }

    public void syntax_error(java_cup.runtime.Symbol s){
        if(s.value != null){
            addSyntacticError(new MError("Simbolo no esperado.", s.value.toString(), s.left, s.right));
        } else{
            String lexeme;
            switch(s.sym){
                case 73: lexeme="+="; break;
                case 57: lexeme=">="; break;
                case 77: lexeme="]"; break;
                case 56: lexeme="<"; break;
                case 82: lexeme=","; break;
                case 78: lexeme="("; break;
                case 71: lexeme="++"; break;          
                case 79: lexeme=")"; break;
                case 64: lexeme="!"; break;
                case 62: lexeme="!||"; break;
                case 58: lexeme="!!"; break;
                case 55: lexeme=">"; break;
                case 69: lexeme="%"; break;
                case 52: lexeme="=="; break;
                case 54: lexeme="<"; break;
                case 68: lexeme="/"; break;
                case 65: lexeme="+"; break;
                case 80: lexeme="="; break;
                case 67: lexeme="*"; break;
                case 70: lexeme="^"; break;
                case 81: lexeme=";"; break;
                case 72: lexeme="--"; break;
                case 61: lexeme="||"; break;
                case 74: lexeme="{"; break;
                case 83: lexeme=":"; break;
                case 75: lexeme="}"; break;
                case 53: lexeme="!="; break;
                case 59: lexeme="&&"; break;
                case 60: lexeme="!&&"; break;
                case 63: lexeme="&|"; break;
                case 76: lexeme="["; break;
                default: lexeme="Simbolo no reconocido"; break;
            }
            addSyntacticError(new MError("Simbolo no esperado.", lexeme, s.left, s.right));
        }        
    }

    public void unrecovered_syntax_error(java_cup.runtime.Symbol s){
        //musicInterpreterFrame.addError(new MError(s.left, s.right, ErrorType.SEMANTIC, "No se esperaba el lexema [" +s.value+ "]"));
        System.out.println("No se esperaba el lexema [" +s.sym+ "]");
    } 
:}

/* Terminals */
terminal String STRING, ID, BOOLEAN, TRACK, EXTENDS, KEEP, VAR, INTEGERTYPE, DOUBLETYPE, BOOLEANTYPE,
                STRINGTYPE, CHARACTERTYPE, ARRAY, IF, ELSE, SWITCH, CASE, BREAK, DEFAULT, FOR, WHILE,
                DO, CONTINUE, RETURN, PLAY, WAIT, ORDER, ASCENDENT, DESCENDENT, EVEN, ODD, PRIME, SUMMARIZE,
                LENGTH, MESSAGE, MAIN, C, C8, D, D8, E, F, F8, G, G8, A, A8;

terminal Double DOUBLE;

terminal Integer INTEGER;

terminal Character CHARACTER;    

terminal ISEQUAL, NOTEQUAL, LESSTHAN, GREATERTHAN, LESSTHANOREQUALTO, GREATERTHANOREQUALTO, ISNULL,
         AND, NAND, OR, NOR, XOR, NOT, PLUS, MINUS, ASTERISK, SLASH, MOD, POWER, INCREMENT, DECREMENT,
         INCREMENTANDASSIGMENT, CURLYBRACKETO, CURLYBRACKETC, SQUAREBRACKETO, SQUAREBRACKETC, PARENTHESISO,
         PARENTHESISC, EQUAL, SEMICOLON, COMMA, COLON;

/* Non-terminals */
non terminal Instruction    arithmetic_op, arithmetic_exp, arithmetic_value, logical_op, relational_op, call,
                            logical_exp, logical_exp2, logical_value, main, procedure, function, cycle, conditional, for,
                            while, do_while, if, switch, for_assignment, case, default_case, else;   

non terminal LinkedList<Instruction>    array_dimensions, call_params, op_list, method_statement, global_statement, params, var_list,
                                        cycle_statement, var_declaration, var, var_declaration_assignment, var_assignment,
                                        keep_statement, keep_var_statements, keep_array_statements, cases, else_if, array_declaration,
                                        array, array_declaration_assignment, array_assignment ;

non terminal LinkedList<LinkedList<Instruction>>    dimension, array_values;

non terminal String     call_name, note;

non terminal OrderType     order_type;

non terminal SymbolType     var_type;   
      
non terminal Integer    array_no_dimensions;                  

non terminal    track, extend, extends_list
                ;   

precedence left PLUS, MINUS;
precedence left ASTERISK, SLASH, MOD;
precedence left POWER;
precedence left ISEQUAL, NOTEQUAL, LESSTHAN, GREATERTHAN, LESSTHANOREQUALTO, GREATERTHANOREQUALTO;
precedence left ISNULL;

/* The grammar */
start with track;

//---------------   TRACK    ---------------// 
track::=    TRACK ID:name extend CURLYBRACKETO global_statement:instructions CURLYBRACKETC      {: track = new Track(name, instructions, nameleft, nameright); :}
            | TRACK ID:name  extend CURLYBRACKETO CURLYBRACKETC                                        {: track = new Track(name, nameleft, nameright); :}
            //Producciones de error
            | TRACK ID extend CURLYBRACKETO error CURLYBRACKETC
            | TRACK ID extend CURLYBRACKETO error global_statement CURLYBRACKETC
            | TRACK ID extend CURLYBRACKETO global_statement error CURLYBRACKETC
            | error TRACK ID extend CURLYBRACKETO global_statement CURLYBRACKETC
            | TRACK ID error CURLYBRACKETO global_statement CURLYBRACKETC
            ;

extend::=   EXTENDS extends_list
            | 
            ;

extends_list::=     extends_list COMMA ID
                    | ID
                    ;

global_statement::=     global_statement:list keep_statement:keepList SEMICOLON     {: list.addAll(keepList); RESULT = list; :}
                        | global_statement:list var:varList SEMICOLON               {: list.addAll(varList); RESULT = list; :}
                        | global_statement:list  array:arrayList SEMICOLON          {: list.addAll(arrayList); RESULT = list; :}      
                        | global_statement:list KEEP procedure:value                {: ((Procedure)value).setKeep(true); list.add(value); RESULT = list; :}
                        | global_statement:list KEEP function:value                 {: ((Function)value).setKeep(true); list.add(value); RESULT = list; :}
                        | global_statement:list KEEP main:value                     {: ((Main)value).setKeep(true); list.add(value); RESULT = list; :}
                        | global_statement:list procedure:value                     {: ((Procedure)value).setKeep(false); list.add(value); RESULT = list; :}
                        | global_statement:list function:value                      {: ((Function)value).setKeep(false); list.add(value); RESULT = list; :}
                        | global_statement:list main:value                          {: ((Main)value).setKeep(false); list.add(value); RESULT = list; :}
                        | keep_statement:keepList SEMICOLON                         {: RESULT = keepList; :}
                        | var:varList SEMICOLON                                     {: RESULT = varList; :}
                        | array:arraylist SEMICOLON                                 {: RESULT = arraylist; :}
                        | KEEP procedure:value                                      {: ((Procedure)value).setKeep(true); RESULT = new LinkedList<Instruction>(); RESULT.add(value); :}
                        | KEEP function:value                                       {: ((Function)value).setKeep(true); RESULT = new LinkedList<Instruction>(); RESULT.add(value); :}  
                        | KEEP main:value                                           {: ((Main)value).setKeep(true); RESULT = new LinkedList<Instruction>(); RESULT.add(value); :}
                        | procedure:value                                           {: ((Procedure)value).setKeep(false); RESULT = new LinkedList<Instruction>(); RESULT.add(value); :}
                        | function:value                                            {: ((Function)value).setKeep(false); RESULT = new LinkedList<Instruction>(); RESULT.add(value); :}  
                        | main:value                                                {: ((Main)value).setKeep(false); RESULT = new LinkedList<Instruction>(); RESULT.add(value); :}

                        //Producciones de error
                        | global_statement error keep_statement SEMICOLON
                        | global_statement error var SEMICOLON
                        | global_statement error array SEMICOLON
                        | global_statement error KEEP procedure
                        | global_statement error KEEP function
                        | global_statement error procedure
                        | global_statement error function
                        | global_statement error main
                        | global_statement error SEMICOLON
                        ;
                        
keep_statement::=   KEEP keep_var_statements:list   {:
                                                        for(int i=0; i<list.size(); i++){
                                                            ((Declaration)list.get(i)).setKeep(true);
                                                        }
                                                        RESULT = list;
                                                    :}
                    | KEEP keep_array_statements:list   {:
                                                            for(int i=0; i<list.size(); i++){
                                                                ((ArrayDeclaration)list.get(i)).setKeep(true);
                                                            }
                                                            RESULT = list;
                                                        :}
                    ;

keep_array_statements::=    array_declaration:list                {: RESULT = list; :}
                            | array_declaration_assignment:list   {: RESULT = list; :}    
                            ;

keep_var_statements::=      var_declaration:list                  {: RESULT = list; :}
                            | var_declaration_assignment:list     {: RESULT = list; :}
                            ;

method_statement::=     method_statement:list var:varList SEMICOLON                 {:list.addAll(varList); RESULT = list; :}
                        | method_statement:list array:arrayList SEMICOLON           {: list.addAll(arrayList); RESULT = list; :}
                        | method_statement:list conditional:instruction             {: list.add(instruction); RESULT = list; :}
                        | method_statement:list cycle:instruction                   {: list.add(instruction); RESULT = list; :}
                        | method_statement:list RETURN:r logical_op:value SEMICOLON {: list.add(new Return(value, rleft, rright)); RESULT = list; :}
                        | method_statement:list call:instruction SEMICOLON          {: list.add(instruction); RESULT = list; :}
                        |                                                           {: RESULT = new LinkedList<Instruction>(); :}       
                        ; 

cycle_statement::=     cycle_statement:list var:varList SEMICOLON                   {:list.addAll(varList); RESULT = list; :}
                        | cycle_statement:list array:arrayList SEMICOLON            {: list.addAll(arrayList); RESULT = list; :}
                        | cycle_statement:list conditional:instruction              {: list.add(instruction); RESULT = list; :}                         
                        | cycle_statement:list cycle:instruction                    {: list.add(instruction); RESULT = list; :}
                        | cycle_statement:list CONTINUE:c SEMICOLON                 {: list.add(new Continue(cleft, cright)); RESULT = list;:}
                        | cycle_statement:list RETURN:r logical_op:value SEMICOLON  {: list.add(new Return(value, rleft, rright)); RESULT = list; :}
                        | cycle_statement:list BREAK:b SEMICOLON                    {: list.add(new Break(bleft, bright)); RESULT = list; :}
                        | cycle_statement:list call:instruction SEMICOLON           {: list.add(instruction); RESULT = list; :}
                        |                                                           {: RESULT = new LinkedList<Instruction>(); :}        
                        ; 

cycle::=    for:value           {: RESULT = value; :}
            | while:value       {: RESULT = value; :}
            | do_while:value    {: RESULT = value; :}
            ;

conditional::=  if:value        {: RESULT = value; :}
                | switch:value  {: RESULT = value; :}
                ;
           

//------------------------------------------------------------------------------------------------------//
//-----------------------------------------------   VAR  -----------------------------------------------//
//------------------------------------------------------------------------------------------------------//
var::=  var_declaration:list                {: RESULT = list; :}
        | var_declaration_assignment:list   {: RESULT = list; :}
        | var_assignment:list               {: RESULT = list; :}
        ;

//---------------   VAR DECLARATION   ---------------//
var_declaration::=  VAR var_type:type var_list:list         {:
                                                                for(int i=0; i<list.size(); i++){
                                                                    ((Declaration)list.get(i)).setSymbolType(type);
                                                                }
                                                                RESULT = list;
                                                            :}
                    ;

var_type::=     INTEGERTYPE         {: RESULT = SymbolType.INTEGER; :}
                | DOUBLETYPE        {: RESULT = SymbolType.DOUBLE; :}
                | BOOLEANTYPE       {: RESULT = SymbolType.BOOLEAN; :}
                | STRINGTYPE        {: RESULT = SymbolType.STRING; :}
                | CHARACTERTYPE     {: RESULT = SymbolType.CHARACTER; :}
                ;

var_list::=     var_list:list COMMA ID:value        {: list.add(new Declaration(value, valueleft, valueright)); RESULT = list; :}
                | ID:value                          {: RESULT = new LinkedList<Instruction>(); RESULT.add(new Declaration(value, valueleft, valueright)); :}
                ;

//---------------   VAR DECLARATION AND ASSIGNMENT   ---------------//
var_declaration_assignment::=   var_declaration:list EQUAL logical_op:value   {:
                                                                                  for(int i=0; i<list.size(); i++){
                                                                                        ((Declaration)list.get(i)).setValue(value);
                                                                                    }
                                                                                    RESULT = list;
                                                                                :}
                                ;                                              
                               

//---------------   VAR ASSIGNMENT   ---------------//
var_assignment::=   ID:id EQUAL logical_op:value                        {: RESULT = new LinkedList<Instruction>(); RESULT.add(new Assignment(id, value, idleft, idright)); :}
                    | ID:id INCREMENTANDASSIGMENT:i logical_op:value    {: RESULT = new LinkedList<Instruction>(); RESULT.add(new Assignment(id, new Operation(new Operation(id, OperationType.ID, idleft, idright), value, OperationType.SUM, ileft, iright), idleft, idright)); :}
                    | ID:id INCREMENT                                   {: RESULT = new LinkedList<Instruction>(); RESULT.add(new Increment(new Operation(id, OperationType.ID, idleft, idright), idleft, idright)); :} 
                    | ID:id DECREMENT                                   {: RESULT = new LinkedList<Instruction>(); RESULT.add(new Decrement(new Operation(id, OperationType.ID, idleft, idright), idleft, idright)); :}
                    ;

//------------------------------------------------------------------------------------------------------//
//---------------------------------------------   ARRAY    ---------------------------------------------//
//------------------------------------------------------------------------------------------------------//
array::=    array_declaration:list                  {: RESULT = list; :}
            | array_declaration_assignment:list     {: RESULT = list; :}
            | array_assignment:list                 {: RESULT = list; :}
            ;

//---------------   ARRAY DECLARATION   ---------------//
array_declaration::=    VAR var_type:type ARRAY var_list:declarations array_dimensions:dimensions   {:
                                                                                                        RESULT = new LinkedList<Instruction>();
                                                                                                        for(int i=0; i<declarations.size(); i++){
                                                                                                            RESULT.add(new ArrayDeclaration((Declaration)declarations.get(i), type, dimensions));
                                                                                                        }
                                                                                                    :}
                        ;

array_dimensions::=     array_dimensions:list SQUAREBRACKETO logical_op:value SQUAREBRACKETC    {: list.add(value); RESULT = list; :}
                        | SQUAREBRACKETO logical_op:value SQUAREBRACKETC                        {: RESULT = new LinkedList<Instruction>(); RESULT.add(value); :}
                        ;

//---------------   ARRAY DECLARATION AND ASSIGNMENT    ---------------//
array_declaration_assignment::=    VAR var_type:type ARRAY var_list:declarations array_no_dimensions:dimensions EQUAL array_values:value    {:
                                                                                                                                                RESULT = new LinkedList<Instruction>();
                                                                                                                                                for(int i=0; i<declarations.size(); i++){
                                                                                                                                                    RESULT.add(new ArrayDeclaration((Declaration)declarations.get(i), type, dimensions, value));
                                                                                                                                                }
                                                                                                                                            :}
                                    ;

array_no_dimensions::=      array_no_dimensions:counter SQUAREBRACKETO SQUAREBRACKETC   {: RESULT =  counter+1; :}
                            | SQUAREBRACKETO  SQUAREBRACKETC                            {: RESULT = 1; :}
                            ;

array_values::=     CURLYBRACKETO:c op_list:values CURLYBRACKETC         {: RESULT = new LinkedList(); RESULT.add(values); :}
                    | CURLYBRACKETO:c dimension:values CURLYBRACKETC     {: RESULT = values; :}
                    ;

op_list::=  op_list:list COMMA logical_op:value     {: list.add(value); RESULT = list; :}
            | logical_op:value                      {: RESULT = new LinkedList<Instruction>(); RESULT.add(value); :}
            ;

dimension::=    dimension:list COMMA CURLYBRACKETO op_list:values CURLYBRACKETC     {: list.add(values); RESULT = list; :}
                | CURLYBRACKETO op_list:values CURLYBRACKETC                        {: RESULT = new LinkedList<>(); RESULT.add(values); :}
                ;

//---------------   ARRAY ASSIGNMENT   ---------------//
array_assignment::=     ID:id array_dimensions:dimensions EQUAL logical_op:value        {: RESULT = new LinkedList(); RESULT.add(new ArrayAssignment(id, dimensions, value, idleft, idright)); :}
                        ;


//------------------------------------------------------------------------------------------------------//
//-----------------------------------------------   IF   -----------------------------------------------//
//------------------------------------------------------------------------------------------------------//
if::=               IF:i PARENTHESISO logical_op:condition PARENTHESISC CURLYBRACKETO method_statement:instructions CURLYBRACKETC else_if:elseList else:elseInstruction     {: RESULT = new If(condition, instructions, elseList, elseInstruction, ileft, iright); :}
                    ;

else_if::=          else_if:list ELSE:e IF PARENTHESISO logical_op:condition PARENTHESISC CURLYBRACKETO method_statement:instructions CURLYBRACKETC     {: list.add(new ElseIf(condition, instructions, eleft, eright)); RESULT = list; :}
                    |                                                                                                                                   {: RESULT = new LinkedList<Instruction>(); :}                                                                                                      
                    ;

else::=             ELSE:e CURLYBRACKETO method_statement:instructions CURLYBRACKETC    {: RESULT = new Else(instructions, eleft, eright); :}   
                    |                                                                   {: RESULT = null; :}
                    ;


//------------------------------------------------------------------------------------------------------//
//---------------------------------------------   SWITCH   ---------------------------------------------//
//------------------------------------------------------------------------------------------------------//
switch::=   SWITCH:s PARENTHESISO ID:id PARENTHESISC CURLYBRACKETO cases:cases default_case:defaultC CURLYBRACKETC  {: RESULT = new Switch(new Operation(id, OperationType.ID, idleft,idright), cases, defaultC, idleft, idright); :}
            | SWITCH:s PARENTHESISO ID:id PARENTHESISC CURLYBRACKETO cases:cases CURLYBRACKETC                      {: RESULT = new Switch(new Operation(id, OperationType.ID, idleft,idright), cases, idleft, idright); :}
            ;

cases::=    cases:list case:instruction     {: list.add(instruction); RESULT = list; :}
            |                               {: RESULT = new LinkedList<Instruction>(); :}
            ;

case::=     CASE:c logical_op:value COLON method_statement:instructions BREAK:b SEMICOLON   {: instructions.add(new Break(bleft, bright)); RESULT = new Case(value, instructions, cleft, cright); :}
            | CASE:c logical_op:value COLON method_statement:instructions                   {: RESULT = new Case(value, instructions, cleft, cright); :}
            ;

default_case::=     DEFAULT:d COLON method_statement:instructions BREAK:b SEMICOLON           {: instructions.add(new Break(bleft, bright)); RESULT = new DefaultCase(instructions, dleft, dright); :}
                    | DEFAULT:d COLON method_statement:instructions                           {: RESULT = new DefaultCase(instructions, dleft, dright); :}
                    ;

//------------------------------------------------------------------------------------------------------//
//---------------------------------------------     FOR    ---------------------------------------------//
//------------------------------------------------------------------------------------------------------//
for::=  FOR:f PARENTHESISO for_assignment:assignment SEMICOLON logical_op:condition SEMICOLON var_assignment:action PARENTHESISC CURLYBRACKETO cycle_statement:instructions  CURLYBRACKETC    {: RESULT = new For(assignment, condition, action.get(0), instructions, fleft, fright); :}
        ;

for_assignment::=   VAR var_type:type ID:id EQUAL logical_op:value    {: RESULT = new Declaration(type, id, value, idleft, idright); :}
                    | ID:id EQUAL logical_op:value                    {: RESULT = new Assignment(id, value, idleft, idright); :}
                    ;


//------------------------------------------------------------------------------------------------------//
//---------------------------------------------    WHILE   ---------------------------------------------//
//------------------------------------------------------------------------------------------------------//
while::=    WHILE:w PARENTHESISO logical_op:condition PARENTHESISC CURLYBRACKETO cycle_statement:instructions CURLYBRACKETC     {: RESULT = new While(condition, instructions, wleft, wright); :}
            ;


//------------------------------------------------------------------------------------------------------//
//---------------------------------------------  DO WHILE  ---------------------------------------------//
//------------------------------------------------------------------------------------------------------//
do_while::=     DO:d CURLYBRACKETO cycle_statement:instructions CURLYBRACKETC WHILE PARENTHESISO logical_op:condition PARENTHESISC     {: RESULT = new DoWhile(condition, instructions, dleft, dright); :}
                ;


//------------------------------------------------------------------------------------------------------//
//---------------------------------------------  FUNCTION  ---------------------------------------------//
//------------------------------------------------------------------------------------------------------//
function::=     var_type:type ID:id PARENTHESISO params:params PARENTHESISC CURLYBRACKETO method_statement:instructions CURLYBRACKETC   {: RESULT = new Function(type, id, params, instructions, idleft, idright); :}
                | var_type:type ID:id PARENTHESISO PARENTHESISC CURLYBRACKETO method_statement:instructions CURLYBRACKETC               {: RESULT = new Function(type, id, instructions, idleft, idright); :}
                ;


//------------------------------------------------------------------------------------------------------//
//---------------------------------------------  PROCEDURE ---------------------------------------------//
//------------------------------------------------------------------------------------------------------//
procedure::=    ID:id PARENTHESISO params:params PARENTHESISC CURLYBRACKETO method_statement:instructions CURLYBRACKETC     {: RESULT = new Procedure(id, params, instructions, idleft, idright); :}
                | ID:id PARENTHESISO PARENTHESISC CURLYBRACKETO method_statement:instructions CURLYBRACKETC                 {: RESULT = new Procedure(id, instructions, idleft, idright); :}
                ;

params::=   params:list COMMA var_type:type ID:id                                       {: list.add(new Param(id, type, idleft, idright)); RESULT = list; :}
            | var_type:type ID:id                                                       {: RESULT = new LinkedList<Instruction>(); RESULT.add(new Param(id, type, idleft, idright)); :}
            ;


//------------------------------------------------------------------------------------------------------//
//---------------------------------------------    CALL    ---------------------------------------------//
//------------------------------------------------------------------------------------------------------//
call::=     call_name:name PARENTHESISO call_params:params PARENTHESISC                                                         {: RESULT = new Call(name, params, nameleft, nameright); :}
            | call_name:name  PARENTHESISO PARENTHESISC                                                                         {: RESULT = new Call(name, nameleft, nameright); :}
            | PLAY:p PARENTHESISO note:note COMMA logical_op:eighth COMMA logical_op:time COMMA logical_op:channel PARENTHESISC {: RESULT = new Play(note, eighth, time, channel, pleft, pright); :}
            | WAIT:w PARENTHESISO logical_op:time COMMA logical_op:channel PARENTHESISC                                         {: RESULT = new Wait(time, channel, wleft, wright); :}
            | ORDER:o PARENTHESISO ID:value COMMA order_type:type PARENTHESISC                                                  {: RESULT = new Order(new Operation(value, OperationType.ALL_ARRAY, valueleft, valueright), type, oleft, oright); :}
            | ORDER:o PARENTHESISO array_values:values COMMA order_type:type PARENTHESISC                                       {: RESULT = new Order(values, type, oleft, oright); :}
            | SUMMARIZE:s PARENTHESISO ID:value PARENTHESISC                                                                    {: RESULT = new Summarize(new Operation(value, OperationType.ALL_ARRAY, valueleft, valueright), sleft, sright); :}
            | SUMMARIZE:s PARENTHESISO  array_values:values PARENTHESISC                                                        {: RESULT = new Summarize(values, sleft, sright); :}    
            | LENGTH:n PARENTHESISO logical_op:value PARENTHESISC                                                               {: RESULT = new Length(value, nleft, nright); :}
            | LENGTH:n PARENTHESISO array_values:values PARENTHESISC                                                            {: RESULT = new Length(values, nleft, nright); :}
            | MESSAGE:m PARENTHESISO logical_op:value PARENTHESISC                                                              {: RESULT = new Message(value, mleft, mright); :}
            ;

call_name::=    ID:value        {: RESULT = value; :}
                | MAIN:value    {: RESULT = value; :}
                ;

call_params::=  call_params:list COMMA logical_op:value      {: list.add(value); RESULT = list; :}
                | logical_op:value                           {: RESULT = new LinkedList<Instruction>(); RESULT.add(value); :}
                ;

note::=     A       {: RESULT = "A"; :}
           | A8     {: RESULT = "A#"; :}
           | IF     {: RESULT = "B"; :}
           | C      {: RESULT = "C"; :}
           | C8     {: RESULT = "C#"; :}
           | D      {: RESULT = "D"; :}
           | D8     {: RESULT = "D#"; :}
           | E      {: RESULT = "E"; :}
           | F      {: RESULT = "F"; :}
           | F8     {: RESULT = "F#"; :}
           | G      {: RESULT = "G"; :}
           | G8     {: RESULT = "G#"; :}
           ;

order_type::=   ODD             {: RESULT = OrderType.ODD; :}
                | EVEN          {: RESULT = OrderType.EVEN; :}
                | PRIME         {: RESULT = OrderType.PRIME; :}
                | ASCENDENT     {: RESULT = OrderType.ASCENDENT; :}
                | DESCENDENT    {: RESULT = OrderType.DESCENDENT; :}
                ;

//------------------------------------------------------------------------------------------------------//
//---------------------------------------------    MAIN    ---------------------------------------------//
//------------------------------------------------------------------------------------------------------//
main::=     MAIN:name PARENTHESISO PARENTHESISC CURLYBRACKETO method_statement:instructions CURLYBRACKETC  {: RESULT = new Main(name, instructions, nameleft, nameright); :}
            ;

//------------------------------------------------------------------------------------------------------//
//-------------------------------------------   OPERATION    -------------------------------------------//
//------------------------------------------------------------------------------------------------------//

//---------------   ARITHMETIC EXPRESSIONS   ---------------//     
arithmetic_op::=    arithmetic_op:value1 PLUS:o arithmetic_exp:value2             {: RESULT = new Operation(value1, value2, OperationType.SUM, oleft, oright); :}
                    | arithmetic_op:value1 MINUS:o arithmetic_exp:value2          {: RESULT = new Operation(value1, value2, OperationType.SUBTRACTION, oleft, oright); :}
                    | arithmetic_op:value1 ASTERISK:o arithmetic_exp:value2       {: RESULT = new Operation(value1, value2, OperationType.MULTIPLICATION, oleft, oright); :}
                    | arithmetic_op:value1 SLASH:o arithmetic_exp:value2          {: RESULT = new Operation(value1, value2, OperationType.DIVISION, oleft, oright); :}
                    | arithmetic_op:value1 MOD:o arithmetic_exp:value2            {: RESULT = new Operation(value1, value2, OperationType.MOD, oleft, oright); :}
                    | arithmetic_op:value1 POWER:o arithmetic_exp:value2          {: RESULT = new Operation(value1, value2, OperationType.POTENTIATION, oleft, oright); :}
                    | arithmetic_exp:value                                        {: RESULT = value; :}
                    ;

arithmetic_exp::=   PLUS:o arithmetic_value:value             {: RESULT = new Operation(value, OperationType.PLUS, oleft, oright); :}
                    | MINUS:o arithmetic_value:value          {: RESULT = new Operation(value, OperationType.MINUS, oleft, oright); :}
                    | arithmetic_value:value                  {: RESULT = value; :}
                    ;
                    
arithmetic_value::=     PARENTHESISO logical_op:value PARENTHESISC  {: RESULT = value; :}
                        | DOUBLE:value                              {: RESULT = new Operation(value, valueleft, valueright); :}
                        | INTEGER:value                             {: RESULT = new Operation(value, valueleft, valueright); :}
                        | CHARACTER:value                           {: RESULT = new Operation(value, valueleft, valueright); :}
                        | BOOLEAN:value                             {: switch(value){
                                                                            case "verdadero": case "Verdadero": case "True": case "true":
                                                                                RESULT = new Operation(true, valueleft, valueright);
                                                                                break;
                                                                            case "falso": case "Falso": case "false": case "False":
                                                                                RESULT = new Operation(false, valueleft, valueright);
                                                                                break;
                                                                        }
                                                                    :}
                        | ID:value                                  {: RESULT = new Operation(value, OperationType.ID, valueleft, valueright); :}
                        | STRING:value                              {: RESULT = new Operation(value, OperationType.STRING, valueleft, valueright); :}
                        | ID:value array_dimensions:dimensions      {: RESULT = new Operation(value, dimensions, valueleft, valueright); :}
                        | call:value                                {: RESULT = new Operation(value, OperationType.CALL, valueleft, valueright); :}
                        ;

//---------------   RELATIONAL EXPRESSIONS   ---------------//  
relational_op::=    arithmetic_op:value1 ISEQUAL:o arithmetic_op:value2                   {: RESULT = new Operation(value1, value2, OperationType.ISEQUAL, oleft, oright); :}
                    | arithmetic_op:value1 NOTEQUAL:o arithmetic_op:value2                {: RESULT = new Operation(value1, value2, OperationType.NOTEQUAL, oleft, oright); :}
                    | arithmetic_op:value1 GREATERTHAN:o arithmetic_op:value2             {: RESULT = new Operation(value1, value2, OperationType.GREATERTHAN, oleft, oright); :}
                    | arithmetic_op:value1 LESSTHAN:o arithmetic_op:value2                {: RESULT = new Operation(value1, value2, OperationType.LESSTHAN, oleft, oright); :}
                    | arithmetic_op:value1 GREATERTHANOREQUALTO:o arithmetic_op:value2    {: RESULT = new Operation(value1, value2, OperationType.GREATERTHANOREQUALTO, oleft, oright); :}
                    | arithmetic_op:value1 LESSTHANOREQUALTO:o arithmetic_op:value2       {: RESULT = new Operation(value1, value2, OperationType.LESSTHANOREQUALTO, oleft, oright); :}
                    | ISNULL:o ID:value array_dimensions:dimensions                       {: RESULT = new Operation(new Operation(value, dimensions, OperationType.NULL_VAR, valueleft, valueright), OperationType.ISNULL, oleft, oright); :} 
                    | ISNULL:o ID:value                                                   {: RESULT = new Operation(new Operation(value, OperationType.NULL_VAR, valueleft, valueright), OperationType.ISNULL, oleft, oright); :}
                    | arithmetic_op:value                                                 {: RESULT = value; :}
                    ;

//---------------   LOGICAL EXPRESSIONS   ---------------//
logical_op::=   logical_op:value1 OR:o logical_exp:value2         {: RESULT = new Operation(value1, value2, OperationType.OR, oleft, oright); :}
                | logical_op:value1 NOR:o logical_exp:value2      {: RESULT = new Operation(value1, value2, OperationType.NOR, oleft, oright); :}
                | logical_op:value1 XOR:o logical_exp:value2      {: RESULT = new Operation(value1, value2, OperationType.XOR, oleft, oright); :}
                | logical_exp:value                               {: RESULT = value; :}                      
                ;

logical_exp::=  logical_exp:value1 AND:o logical_exp2:value2      {: RESULT = new Operation(value1, value2, OperationType.AND, oleft, oright); :}
                | logical_exp:value1 NAND:o logical_exp2:value2   {: RESULT = new Operation(value1, value2, OperationType.NAND, oleft, oright); :}
                | logical_exp2:value                              {: RESULT = value; :}
                ;
                
logical_exp2::=     NOT logical_value:value     {: RESULT = new Operation(value, OperationType.NOT, valueleft, valueright); :}
                    | logical_value:value       {: RESULT = value; :}
                    ;

logical_value::=    relational_op:value         {: RESULT = value; :}
                    ;